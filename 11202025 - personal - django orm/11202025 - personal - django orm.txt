Django ORM

--------------------------------------------------------------------------
Models - Reference
class Blog(models.Model):
    name = models.CharField(max_length=200)

class Author(models.Model):
    name = models.CharField(max_length=200)

class Entry(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    authors = models.ManyToManyField(Author)
    blog = models.ForeignKey(Blog, on_delete=models.CASCADE)
    created_at = models.DateTimeField()
    updated_at = models.DateTimeField()
--------------------------------------------------------------------------




1. Basic QuerySet Operations
ORM Feature	Simple Description

-------------------------------------------------------------
.all()	Get all records.
-------------------------------------------------------------
Blog.objects.all()
Entry.objects.all()
Entry.objects.all()[:5]
Entry.objects.all()[5:15]



-------------------------------------------------------------
.get()	Get one record; error if none or more than one.
-------------------------------------------------------------
Author.objects.get(id=1)
Blog.objects.get(name="Tech Blog")
Entry.objects.get(pk=1)



-------------------------------------------------------------
.filter()	Get records that match conditions.
-------------------------------------------------------------
Entry.objects.filter(title__icontains="django")
Entry.objects.filter(created_at__year=2024)
Entry.objects.filter(blog_id=1)



-------------------------------------------------------------
.exclude()	Get records that do NOT match conditions.
-------------------------------------------------------------
Entry.objects.exclude(blog_id=1)
Author.objects.exclude(name__startswith="A")



-------------------------------------------------------------
.order_by()	Sort results (ASC or DESC).
-------------------------------------------------------------
Entry.objects.order_by("-created_at")  # Newest first
Entry.objects.order_by("blog", "title")



-------------------------------------------------------------
.first() / .last()	Return the first/last object (or None).
-------------------------------------------------------------
Entry.objects.first()
Entry.objects.order_by("-created_at").last()



-------------------------------------------------------------
.reverse()	Reverse the order of a queryset.
-------------------------------------------------------------
Entry.objects.order_by("created_at").reverse()
Entry.objects.reverse()



-------------------------------------------------------------
.values()	Return dicts instead of model instances.
-------------------------------------------------------------
# Returns dicts instead of objects.
Entry.objects.values("id", "title")

# Include related fields:
Entry.objects.values("title", "blog__name")



-------------------------------------------------------------
.distinct()	Remove duplicate rows.
-------------------------------------------------------------
# List unique blog IDs:
Entry.objects.values("blog").distinct()

# Unique creation dates:
Entry.objects.values("created_at__date").distinct()



-------------------------------------------------------------
.values_list()	Return tuples instead of model instances.
-------------------------------------------------------------
# Returns tuples.
Entry.objects.values_list("id", "title")
Entry.objects.values_list("title", flat=True)  # list of titles only



-------------------------------------------------------------
.exists()	Quickly check if any record exists.
-------------------------------------------------------------
# Check if ANY record exists (fast).
Entry.objects.filter(blog_id=1).exists()

# Check if an author exists:
Author.objects.filter(name="John").exists()



-------------------------------------------------------------
.count()	Count number of rows (SQL COUNT).
-------------------------------------------------------------
Entry.objects.count()
Entry.objects.filter(blog_id=1).count()



-------------------------------------------------------------
.earliest() / .latest()	Grab earliest or latest by date field.
-------------------------------------------------------------
Entry.objects.earliest("created_at")
Entry.objects.latest("updated_at")



-------------------------------------------------------------
.bulk_create()	Create many objects efficiently.
-------------------------------------------------------------
#
blogs = [
    Blog(name="Tech"),
    Blog(name="Food"),
    Blog(name="Travel"),
]
Blog.objects.bulk_create(blogs)

#
authors = [Author(name=f"Author {i}") for i in range(10)]
Author.objects.bulk_create(authors)



-------------------------------------------------------------
.bulk_update()	Update many objects efficiently.
-------------------------------------------------------------
# Update multiple objects fast (1 SQL query).
entries = Entry.objects.filter(blog_id=1)
for e in entries:
    e.title = e.title + " (Updated)"
Entry.objects.bulk_update(entries, ["title"])

# Update multiple fields:
Entry.objects.bulk_update(entries, ["title", "updated_at"])



-------------------------------------------------------------
.iterator()	Stream results without loading all in memory.
-------------------------------------------------------------
# Fetch results in chunks (memory-friendly).
for entry in Entry.objects.iterator():
    print(entry.title)

# Chunk size (default is 2000):
for entry in Entry.objects.iterator(chunk_size=100):
    process(entry)
















------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------














2. Query Conditions (Lookups)


-------------------------------------------------------------
field=value	Exact match.
-------------------------------------------------------------
Blog.objects.filter(name="Tech Blog")



-------------------------------------------------------------
field__iexact=value	Case-insensitive exact.
-------------------------------------------------------------
# Matches: â€œJohn Doeâ€, â€œJOHN DOEâ€, etc.
Author.objects.filter(name__iexact="john doe")



-------------------------------------------------------------
field__contains=value	case-sensitive substring
-------------------------------------------------------------
Entry.objects.filter(title__contains="Django")



-------------------------------------------------------------
field__icontains=value	Case-insensitive contains.
-------------------------------------------------------------
Entry.objects.filter(title__icontains="django")



-------------------------------------------------------------
field__in=[â€¦]	Value is inside a list.
-------------------------------------------------------------
Blog.objects.filter(id__in=[1, 3, 5])
Blog.objects.filter(pk__in=[1, 3, 5])



-------------------------------------------------------------
field__gt, __gte	Greater than / >=
-------------------------------------------------------------
Entry.objects.filter(created_at__gt="2025-01-01")
Entry.objects.filter(created_at__gte="2025-01-01")



-------------------------------------------------------------
field__lt, __lte	Less than / <=
-------------------------------------------------------------
Entry.objects.filter(created_at__lt="2025-01-01")



-------------------------------------------------------------
field__range=(a, b)	Between A and B.
-------------------------------------------------------------
Entry.objects.filter(created_at__range=("2025-01-01", "2025-01-31"))



-------------------------------------------------------------
field__startswith / __istartswith	Starts withâ€¦
-------------------------------------------------------------
# Case-sensitive:
Author.objects.filter(name__startswith="A")

# Case-insensitive:
Author.objects.filter(name__istartswith="a")



-------------------------------------------------------------
field__endswith / __iendswith	Ends withâ€¦
-------------------------------------------------------------
Entry.objects.filter(title__endswith="Guide")
Entry.objects.filter(title__iendswith="guide")



-------------------------------------------------------------
date__year, date__month, date__day	Filter by date parts.
-------------------------------------------------------------
Entry.objects.filter(created_at__year=2025)

# Entries created in March:
Entry.objects.filter(created_at__month=3)



-------------------------------------------------------------
isnull=True
-------------------------------------------------------------
Entry.objects.filter(blog__isnull=True)
Author.objects.filter(name__isnull=False)



-------------------------------------------------------------
regex / iregex	Match regex.
-------------------------------------------------------------
# Titles that start with a number:
Entry.objects.filter(title__regex=r'^[0-9]')

# Case-insensitive regex:
Entry.objects.filter(title__iregex=r'django.*guide')


















------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------














3. Creating, Updating, Deleting

-------------------------------------------------------------
.create()	Create object and save.
-------------------------------------------------------------
#
Blog.objects.create(name="Tech Blog")

#
Author.objects.create(name="John Doe")

#
Entry.objects.create(
    title="Django Tips",
    content="Learn Django ORM...",
    blog_id=1,  # FK
    created_at="2025-01-01",
    updated_at="2025-01-01",
)

#
Entry.objects.create(
    title="Django Tips",
    content="Learn Django ORM...",
    blog=b,  # FK
    created_at="2025-01-01",
    updated_at="2025-01-01",
)



-------------------------------------------------------------
Model(**fields).save()	Manual object creation.
-------------------------------------------------------------
#
blog = Blog(name="Travel Blog")
blog.save()

#
entry = Entry(
    title="Draft Post",
    content="draft...",
    blog_id=1
)
entry.title = "Final Post"
entry.save()

#
entry = Entry(
    title="M2M Example",
    content="example...",
    blog_id=1
)
entry.save()
entry.authors.add(a1, a2, a3)



-------------------------------------------------------------
.update()	Bulk update fields (fast, no save signals).
-------------------------------------------------------------
#
Entry.objects.filter(blog_id=1).update(title="Updated Title")

#
Entry.objects.filter(id=5).update(
    title="New",
    updated_at="2025-01-01"
)



-------------------------------------------------------------
.delete()	Delete one or many objects.
-------------------------------------------------------------
#
Blog.objects.get(id=3).delete()

#
Entry.objects.filter(title__icontains="draft").delete()

#
Author.objects.all().delete()



-------------------------------------------------------------
.get_or_create()	Get if exists, else create.
-------------------------------------------------------------
#
author, created = Author.objects.get_or_create(name="Alice")

#
entry, created = Entry.objects.get_or_create(
    title="Welcome",
    defaults={
        "content": "Hello world",
        "blog_id": 1
    }
)

#
blog, created = Blog.objects.get_or_create(name="Travel Blog")



-------------------------------------------------------------
.update_or_create()	Update if exists, else create.
-------------------------------------------------------------
#
author, created = Author.objects.update_or_create(
    name="John",
    defaults={"name": "John Doe"}  # update this if found
)

#
entry, created = Entry.objects.update_or_create(
    id=10,
    defaults={
        "title": "New Title",
        "content": "Updated content..."
    }
)

#
blog, created = Blog.objects.update_or_create(
    name="Tech Blog",
    defaults={"name": "Tech Blog"}  # mostly used for other fields
)



-------------------------------------------------------------
.select_for_update()	Lock rows for transaction safety.
-------------------------------------------------------------
#
from django.db import transaction

with transaction.atomic():
    entry = Entry.objects.select_for_update().get(id=1)
    entry.title = "Locked Update"
    entry.save()

#
with transaction.atomic():
    entries = Entry.objects.select_for_update().filter(blog_id=1)
    for e in entries:
        e.title += " (locked)"
        e.save()

#
with transaction.atomic():
    blog = Blog.objects.select_for_update().get(id=1)
    blog.name = blog.name + "!"
    blog.save()

















------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------














4. Relations / Foreign Keys


-------------------------------------------------------------
FORWARD LOOKUPS
-------------------------------------------------------------
# Example 1 â€” Entry â†’ Blog
entry = Entry.objects.get(id=1)
entry.blog.name

# Example 2 â€” Entry â†’ Many Authors
entry = Entry.objects.get(id=1)
authors = entry.authors.all()

# Example 3 â€” Chain lookups (Entry â†’ Blog â†’ something)
entry = Entry.objects.get(id=1)
blog_name = entry.blog.name

# .select_related() - Used for FK and OneToOne relationships (not M2M)
âŒ Without select_related (2 queries):
entries = Entry.objects.all()
for e in entries:
    print(e.blog.name)

âœ” With select_related (1 query):
entries = Entry.objects.select_related("blog")
for e in entries:
    print(e.blog.name)

# 
Entry.objects.select_related("blog", "some_other_fk")

#
Entry.objects.select_related("blog").filter(blog__name="Tech Blog")



-------------------------------------------------------------
REVERSE LOOKUPS
-------------------------------------------------------------



# Reverse FK

Example 1 â€” Get all entries under a blog
	blog = Blog.objects.get(id=1)
	entries = blog.entry_set.all()

Example 2 â€” Filter reverse entries
	blog = Blog.objects.get(id=1)
	recent_entries = blog.entry_set.filter(created_at__year=2025)

Example 3 â€” Count reverse entries
	entry_count = blog.entry_set.count()


# Reverse M2M

Example 1 â€” Get all entries written by an author
	author = Author.objects.get(id=1)
	entries = author.entry_set.all()

Example 2 â€” Filter reverse entries
	author = Author.objects.get(id=1)
	django_entries = author.entry_set.filter(title__icontains="django")

Example 3 â€” Count
	author.entry_set.count()


# .prefetch_related()
> Used for ManyToMany and Reverse Relations (not FK).
> It performs two queries and joins in Python memory â€” perfect for M2M.

	A. Prefetch authors of entries
		Without prefetch_related = N+1 queries.

		âŒ Slow:
		entries = Entry.objects.all()
		for e in entries:
		    print(list(e.authors.all()))

		âœ” Fast:
		entries = Entry.objects.prefetch_related("authors")
		for e in entries:
		    print(list(e.authors.all()))


	B. Prefetch reverse entries (Blog â†’ Entry)
		blogs = Blog.objects.prefetch_related("entry_set")
		for blog in blogs:
		    print(blog.entry_set.all())


	C. Prefetch multiple relationships
		Entry.objects.prefetch_related("authors", "blog")
		âš  Note:
		blog is FK, so this should be select_related("blog") for best performance.
		Correct combined usage:
		Entry.objects.select_related("blog").prefetch_related("authors")


	D. Custom prefetch (advanced but simple)
		Example: Prefetch entries but filter only recent ones.
		from django.db.models import Prefetch
		blogs = Blog.objects.prefetch_related(
		    Prefetch(
		        "entry_set",
		        queryset=Entry.objects.filter(created_at__year=2025)
		    )
		)














------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------














5. Many-to-Many (M2M)


Reference
-------------------------------------------------------------
class Student(models.Model):
    name = models.CharField(max_length=100)

class Course(models.Model):
    title = models.CharField(max_length=100)
    students = models.ManyToManyField(Student, related_name="courses")
-------------------------------------------------------------



-------------------------------------------------------------
obj.m2mfield.add(item)
-------------------------------------------------------------
#
book.authors.add(a1, a2, a3)

#
course.students.add(student1, student2, student3)
#

course.students.add(5)   # student with ID=5
course.students.add(7, 8)



-------------------------------------------------------------
obj.m2mfield.remove(item)
-------------------------------------------------------------
#
course.students.remove(student1, student2)

#
course.students.remove(10)  # student with ID=10



-------------------------------------------------------------
obj.m2mfield.clear()
-------------------------------------------------------------
#
student.courses.clear()

#
for course in Course.objects.filter(title__contains="Math"):
    course.students.clear()



-------------------------------------------------------------
Reverse Lookups (via related_name)
-------------------------------------------------------------

Sample 1 â€” All courses for a student
	student = Student.objects.get(id=10)
	student.courses.all()

Sample 2 â€” Reverse filter
	Student.objects.filter(courses__title="Math 101")

Sample 3 â€” List students who have at least 3 courses
	# annotate is like group-by sql. More on this below
	Student.objects.annotate(num=Count("courses")).filter(num__gte=3)



-------------------------------------------------------------
prefetch_related()
-------------------------------------------------------------

Sample 1 â€” Fetch courses with all related students
	courses = Course.objects.prefetch_related("students")
	for c in courses:
	    print(c.title, c.students.all())  # no extra queries

Sample 2 â€” Prefetch multiple M2M
	students = Student.objects.prefetch_related("courses")

Sample 3 â€” Prefetch with filter (using Prefetch)
	from django.db.models import Prefetch
	courses = Course.objects.prefetch_related(
	    Prefetch("students", queryset=Student.objects.filter(name__startswith="J"))
	)








------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------














6. Aggregation & Annotation


Reference
-------------------------------------------------------------
class Order(models.Model):
    customer = models.CharField(max_length=100)
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    quantity = models.IntegerField()
    created_at = models.DateTimeField(auto_now_add=True)
-------------------------------------------------------------



-------------------------------------------------------------
Sum
-------------------------------------------------------------
Aggregate â€” compute summary for the whole queryset
from django.db.models import Sum

Sample 1 â€” Total sales amount
	Order.objects.aggregate(total=Sum("amount"))

Sample 2 â€” Total quantity sold
	Order.objects.aggregate(total_qty=Sum("quantity"))

Sample 3 â€” Sum with condition
	Order.objects.filter(customer="John").aggregate(john_total=Sum("amount"))



-------------------------------------------------------------
Avg
-------------------------------------------------------------
from django.db.models import Avg

Sample 1 â€” Average order amount
	Order.objects.aggregate(avg_amount=Avg("amount"))

Sample 2 â€” Average quantity per order
	Order.objects.aggregate(avg_qty=Avg("quantity"))

Sample 3 â€” Avg for a filtered set
	Order.objects.filter(customer="Anna").aggregate(avg=Avg("amount"))



-------------------------------------------------------------
Max
-------------------------------------------------------------
from django.db.models import Max

Sample 1 â€” Highest order amount
	Order.objects.aggregate(max_amount=Max("amount"))

Sample 2 â€” Latest order date
	Order.objects.aggregate(last_order=Max("created_at"))

Sample 3 â€” Max with condition
	Order.objects.filter(customer="Anna").aggregate(max_qty=Max("quantity"))



-------------------------------------------------------------
Min
-------------------------------------------------------------
from django.db.models import Min

Sample 1 â€” Lowest order amount
	Order.objects.aggregate(min_amount=Min("amount"))

Sample 2 â€” First order date
	Order.objects.aggregate(first_order=Min("created_at"))

Sample 3 â€” Min with filter
	Order.objects.filter(customer="John").aggregate(min_qty=Min("quantity"))



-------------------------------------------------------------
Count
-------------------------------------------------------------
from django.db.models import Count

Sample 1 â€” Count all orders
	Order.objects.aggregate(count=Count("id"))

Sample 2 â€” Count orders for a customer
	Order.objects.filter(customer="John").aggregate(total=Count("id"))

Sample 3 â€” Count distinct customers
	Order.objects.aggregate(unique_customers=Count("customer", distinct=True))



-------------------------------------------------------------
.aggregate()	Returns overall statistics.
-------------------------------------------------------------
> Returns a single dictionary of overall values
> .aggregate() summarizes the entire queryset into one result.

Sample 1 â€” Multiple aggregates at once
	Order.objects.aggregate(
	    total=Sum("amount"),
	    avg=Avg("amount"),
	    highest=Max("amount")
	)

Sample 2 â€” Mixed types
	Order.objects.aggregate(
	    total_qty=Sum("quantity"),
	    min_date=Min("created_at")
	)

Sample 3 â€” Aggregate after filtering
	Order.objects.filter(customer="Anna").aggregate(
	    total=Sum("amount"),
	    orders=Count("id")
	)



-------------------------------------------------------------
.annotate()	Adds calculated fields to each row.
-------------------------------------------------------------
> .annotate() is like SQL GROUP BY.
> Each object in the queryset gets an extra field.
> When does annotate() group?
	If you annotate without .values() â†’ group by primary key.
	If you annotate with .values("field") â†’ group by that field.


Sample 1 â€” Add total_price for each Order
	Order.objects.annotate(total_price=Sum("amount"))
	(Not very useful on a single model but good for multi-table.)

Sample 2 â€” Count orders per customer
	Order.objects.values("customer").annotate(
	    order_count=Count("id")
	)
	Output:
	[
	  {"customer": "John", "order_count": 5},
	  {"customer": "Anna", "order_count": 3},
	]

	# sql - pila na ka buok ang record for each specific customer
	SELECT 
		customer, 
		COUNT(id) AS order_count 
	FROM 
		order 
	GROUP BY 
		customer;

Sample 3 â€” Average order amount per customer
	Order.objects.values("customer").annotate(
	    avg_amount=Avg("amount")
	)

Sample 4 â€” Add month to each order (useful for reporting)
	from django.db.models.functions import TruncMonth
	Order.objects.annotate(month=TruncMonth("created_at"))

Sample 5 â€” Group by month + total sales
	Order.objects.annotate(
	    month=TruncMonth("created_at")
	).values("month").annotate(
	    total_sales=Sum("amount")
	)

Sample 6 â€” Count orders per day
	from django.db.models.functions import TruncDay
	Order.objects.annotate(day=TruncDay("created_at")).values("day").annotate(
	    total=Count("id")
	)












------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------














7. Expressions (F, Q, Case, When, etc.)


Reference
-------------------------------------------------------------
class Product(models.Model):
    name = models.CharField(max_length=100)
    price = models.DecimalField(max_digits=10, decimal_places=2)
    stock = models.IntegerField(default=0)
    sold = models.IntegerField(default=0)
    created_at = models.DateTimeField(auto_now_add=True)
-------------------------------------------------------------



-------------------------------------------------------------
F Expressions
-------------------------------------------------------------
> Use F expressions when updating a field based on its own value
> avoids race conditions, ensures DB writes correct values.

âœ” Sample 1 â€” Increase stock by 10
	from django.db.models import F
	Product.objects.update(stock=F("stock") + 10)

âœ” Sample 2 â€” Decrease stock based on sold
	Product.objects.update(stock=F("stock") - F("sold"))

âœ” Sample 3 â€” Update price to 90% of old price
	Product.objects.update(price=F("price") * 0.9)

âœ” Sample 4 â€” Update one field based on another
	Product.objects.update(sold=F("stock"))

âœ” Sample 5 â€” Filter using F expressions
	# get items where stock < sold
	Product.objects.filter(stock__lt=F("sold"))



-------------------------------------------------------------
Q Expressions
-------------------------------------------------------------
> Use Q for complex OR / AND / NOT conditions

âœ” Sample 1 â€” OR condition
	from django.db.models import Q
	Product.objects.filter(
	    Q(stock__lt=10) | Q(price__lt=100)
	)

âœ” Sample 2 â€” Combine AND + OR
	Product.objects.filter(
	    Q(price__lt=100) & (Q(stock__lt=5) | Q(name__icontains="promo"))
	)

âœ” Sample 3 â€” Exclude products with certain names
	(NOT logic)
	Product.objects.filter(~Q(name__in=["Apple", "Banana"]))

âœ” Sample 4 â€” Search multiple fields
	(often used for search bars)
	Product.objects.filter(
	    Q(name__icontains="phone") | Q(description__icontains="phone")
	)



-------------------------------------------------------------
Case / When
-------------------------------------------------------------
> Conditional expressions â€” like SQL CASE WHEN
> Useful for:
	> dynamic fields
	> sorting
	> conditional updates
	> labeling rows

from django.db.models import Case, When, Value, IntegerField, F
âœ” Sample 1 â€” Label products based on stock levels
	Product.objects.annotate(
	    status=Case(
	        When(stock__gt=20, then=Value("In Stock")),
	        When(stock__gt=0, then=Value("Low Stock")),
	        default=Value("Out of Stock")
	    )
	)

âœ” Sample 2 â€” Apply discount only to expensive items
	Product.objects.update(
	    price=Case(
	        When(price__gt=500, then=F("price") * 0.9),
	        default=F("price")
	    )
	)

âœ” Sample 3 â€” Order by priority (custom ordering)
	Example: Items with stock 0 appear first.
	Product.objects.annotate(
	    priority=Case(
	        When(stock=0, then=Value(0)),
	        default=Value(1),
	        output_field=IntegerField(),
	    )
	).order_by("priority", "name")

âœ” Sample 4 â€” Conditional count / flags
	Flag expired items:
	Product.objects.annotate(
	    low_stock_flag=Case(
	        When(stock__lte=5, then=Value(1)),
	        default=Value(0),
	        output_field=IntegerField()
	    )
	)

âœ” Sample 5 â€” Grouping by condition
	Count low-stock vs normal-stock:
	from django.db.models import Count
	Product.objects.annotate(
	    bucket=Case(
	        When(stock__lte=5, then=Value("low")),
	        default=Value("normal"),
	    )
	).values("bucket").annotate(count=Count("id"))






















------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------














8. Advanced QuerySet Features

-------------------------------------------------------------
raw()	Write raw SQL queries.
-------------------------------------------------------------
âœ” Sample 1 â€” basic raw query
	entries = Entry.objects.raw("SELECT * FROM app_entry")

âœ” Sample 2 â€” with parameter binding (recommended!)
	entries = Entry.objects.raw(
	    "SELECT * FROM app_entry WHERE likes > %s", [10]
	)

âœ” Sample 3 â€” selecting custom fields
	query = """
	    SELECT id, title, created_at
	    FROM app_entry
	    WHERE blog_id = %s
	"""
	Entry.objects.raw(query, [1])



-------------------------------------------------------------
.extra()	Old way of inserting raw SQL fragments (deprecated).
-------------------------------------------------------------
Replacement for .extra()
Use annotate(), RawSQL, Func, F, Case, When, Subqueries, etc.



-------------------------------------------------------------
.union() Combine querysets like SQL set operations.
-------------------------------------------------------------
âœ” Sample 1 â€” Union of two title lists
	q1 = Entry.objects.filter(likes__gt=10).values("title")
	q2 = Entry.objects.filter(likes__lt=2).values("title")

result = q1.union(q2)

âœ” Sample 2 â€” Remove duplicates automatically
	Entry.objects.values("title").union(
	    Entry.objects.values("title")
	)

âœ” Sample 3 â€” Keep duplicates using all=True (Postgres)
	q1.union(q2, all=True)



-------------------------------------------------------------
.intersection() Combine querysets like SQL set operations. Find records common to BOTH QuerySets.
-------------------------------------------------------------
âœ” Sample 1 â€” Entries liked > 10 AND from blog 1
	q1 = Entry.objects.filter(likes__gt=10)
	q2 = Entry.objects.filter(blog_id=1)
	result = q1.intersection(q2)

âœ” Sample 2 â€” intersection on values
	a = Entry.objects.values("author_id")
	b = Entry.objects.filter(likes__gt=0).values("author_id")
	a.intersection(b)



-------------------------------------------------------------
.difference()	Combine querysets like SQL set operations. Records in first QuerySet NOT in the second.
-------------------------------------------------------------
âœ” Sample 1 â€” entries with likes > 10 but NOT in blog 1
	q1 = Entry.objects.filter(likes__gt=10)
	q2 = Entry.objects.filter(blog_id=1)
	result = q1.difference(q2)

âœ” Sample 2 â€” remove authors with any entries
	all_authors = Author.objects.values("id")
	active_authors = Entry.objects.values("author_id")
	all_authors.difference(active_authors)



-------------------------------------------------------------
Subqueries	Query inside query (powerful). insert a query inside another query
-------------------------------------------------------------
âœ” Sample 1 â€” latest entry date per blog
	from django.db.models import Subquery, OuterRef
	latest_entry = Entry.objects.filter(
	    blog=OuterRef("pk")
	).order_by("-created_at")
	Blog.objects.annotate(
	    latest_post=Subquery(latest_entry.values("created_at")[:1])
	)

âœ” Sample 2 â€” entry count per blog
	count_query = Entry.objects.filter(blog=OuterRef("pk")) \
	    .values("blog") \
	    .annotate(count=models.Count("id")) \
	    .values("count")
	Blog.objects.annotate(entry_count=Subquery(count_query))

âœ” Sample 3 â€” get most-liked entryâ€™s title per blog
	top_liked = Entry.objects.filter(blog=OuterRef("pk")) \
	    .order_by("-likes") \
	    .values("title")[:1]
	Blog.objects.annotate(top_entry_title=Subquery(top_liked))







---
SELECT name
FROM employee
WHERE salary > (
    SELECT avg(salary) FROM employee
)

from django.db.models import Avg, Subquery, OuterRef
avg_salary_sq = Employee.objects.all().values(avg_salary=Avg("salary"))
qs = Employee.objects.filter(
    salary__gt=Subquery(avg_salary_sq.values("avg_salary")[:1])
)




---
SELECT
    e.name,
    (SELECT name FROM department d WHERE d.id = e.dept_id) AS department_name
FROM employee e;

from django.db.models import Subquery, OuterRef
dept_name_sq = Department.objects.filter(
    id=OuterRef("department_id")
).values("name")[:1]
qs = Employee.objects.annotate(
    department_name=Subquery(dept_name_sq)
).values("name", "department_name")






---
SELECT
    e.name
FROM
    employee e
JOIN (
        SELECT dept_id, avg(salary) AS dept_avg_salary
        FROM employee
        GROUP BY dept_id
     ) dt
     ON dt.dept_id = e.dept_id
WHERE
    e.salary > dt.dept_avg_salary;

from django.db.models import Avg, Subquery, OuterRef, F
dept_avg_sq = (
    Employee.objects
    .filter(department_id=OuterRef("department_id"))
    .values("department_id")
    .annotate(avg_salary=Avg("salary"))
    .values("avg_salary")[:1]
)
qs = (
    Employee.objects
    .annotate(dept_avg_salary=Subquery(dept_avg_sq))
    .filter(salary__gt=F("dept_avg_salary"))
)








-------------------------------------------------------------
OuterRef	Reference outer query in subquery. reference parent queryset in subquery
-------------------------------------------------------------
âœ” Sample â€” OuterRef + Subquery
	avg_likes = Entry.objects.filter(
	    blog=OuterRef("blog")
	).values("blog").annotate(
	    avg=models.Avg("likes")
	).values("avg")
	Entry.objects.annotate(
	    blog_avg=Subquery(avg_likes)
	).filter(likes__gt=F("blog_avg"))



-------------------------------------------------------------
Exists	Check if related rows exist. quickly check if a subquery has results
-------------------------------------------------------------
âœ” Sample 1 â€” Blogs that have at least 1 entry
	from django.db.models import Exists
	sub = Entry.objects.filter(blog=OuterRef("pk"))
	Blog.objects.annotate(has_posts=Exists(sub))

âœ” Sample 2 â€” Authors with entries
	entries_by_author = Entry.objects.filter(
	    author=OuterRef("pk")
	)
	Author.objects.annotate(
	    has_entries=Exists(entries_by_author)
	)

âœ” Sample 3 â€” Filter only blogs that contain keyword in any entry
	sub = Entry.objects.filter(
	    blog=OuterRef("pk"),
	    title__icontains="django"
	)
	Blog.objects.filter(Exists(sub))
















------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------














9. Model Meta Options


-------------------------------------------------------------
ordering	Default sort order.
-------------------------------------------------------------
class Entry(models.Model):
    blog = models.ForeignKey("Blog", on_delete=models.CASCADE)
    title = models.CharField(max_length=100)

    class Meta:
        ordering = ["blog__name", "title"]



-------------------------------------------------------------
unique_together	Field combinations must be unique.
-------------------------------------------------------------
#
class Entry(models.Model):
    title = models.CharField(max_length=100)
    author = models.ForeignKey("Author", on_delete=models.CASCADE)

    class Meta:
        unique_together = ("title", "author")

# modern preferred
class Meta:
    constraints = [
        models.UniqueConstraint(fields=["title", "author"], name="unique_author_title")
    ]



-------------------------------------------------------------
index_together	Multi-field index.
-------------------------------------------------------------
> Creates combined database indexes for speed.
> Useful when you filter on two fields together a lot.

#
class Entry(models.Model):
    author = models.ForeignKey("Author", on_delete=models.CASCADE)
    created_at = models.DateTimeField()

    class Meta:
        index_together = [
            ("author", "created_at"),
        ]

# modern preferred
class Meta:
    indexes = [
        models.Index(fields=["author", "created_at"])
    ]



-------------------------------------------------------------
db_table	Custom database table name.
-------------------------------------------------------------
> Specifies the database table name manually.

âœ” Example 1 â€” rename table
	class Entry(models.Model):
	    title = models.CharField(max_length=100)
	    class Meta:
	        db_table = "blog_entries"

âœ” Example 2 â€” prefix tables for multitenancy
	class Meta:
	    db_table = "tenant1_entry"

âœ” Example 3 â€” legacy tables
	If old systems use uppercase names:
	class Meta:
	    db_table = "ENTRY_TABLE"



-------------------------------------------------------------
verbose_name Human names.
-------------------------------------------------------------

class Entry(models.Model):
    title = models.CharField(max_length=100)
    class Meta:
        verbose_name = "Blog Entry"



-------------------------------------------------------------
verbose_name_plural	Human names.
-------------------------------------------------------------

âœ” Example â€” irregular plural
class Person(models.Model):
    name = models.CharField(max_length=100)

    class Meta:
        verbose_name_plural = "People"

âœ” Example â€” override default English plural
class Category(models.Model):
    name = models.CharField(max_length=100)

    class Meta:
        verbose_name_plural = "Categories"

















------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------














10. Transactions

! transaction.atomic()	Block of SQL that must succeed or fail as a whole.
! select_for_update()	Locks rows (avoid race conditions).
! Savepoints	Roll back part of a block.

these are done in other topics












------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------














11. Custom Manager (classic way)


Reference
-------------------------------------------------------------
class Entry(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    likes = models.IntegerField(default=0)
    published = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
-------------------------------------------------------------


> A Manager is an interface to DB operations.
> Default: objects = models.Manager()

âœ” Example 1 â€” Basic custom manager
	class EntryManager(models.Manager):
	    def published(self):
	        return self.filter(published=True)

	    def popular(self):
	        return self.filter(likes__gte=100)


Attach it:
	class Entry(models.Model):
	    ...
	    objects = EntryManager()


Use it:
	Entry.objects.published()
	Entry.objects.popular()

â— Problem of classic Managers

	Methods are NOT chainable without special handling.
	Example:
		Entry.objects.published().popular()  
		âž¡ Works only because they return QuerySet
		âž¡ But more advanced logic breaks

To fix chainability we must use Custom QuerySets.











------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------














12. Custom QuerySet (recommended modern method)



âœ” Example 2 â€” Custom QuerySet
	class EntryQuerySet(models.QuerySet):
	    def published(self):
	        return self.filter(published=True)

	    def popular(self):
	        return self.filter(likes__gte=100)


Attach to Manager:
	class EntryManager(models.Manager):
	    def get_queryset(self):
	        return EntryQuerySet(self.model, using=self._db)

	    # Optional: expose QuerySet methods directly
	    def published(self):
	        return self.get_queryset().published()

	    def popular(self):
	        return self.get_queryset().popular()


Attach both to model:

	class Entry(models.Model):
	    ...
	    objects = EntryManager()

ðŸ§ª Now usage becomes chainable:
Entry.objects.published().popular().order_by("-created_at")







-------------------------------------------------------------
Chainable Custom QuerySet Business Logic Examples
-------------------------------------------------------------

âœ” Example A â€” last 7 days entries
	from django.utils import timezone
	from datetime import timedelta

	class EntryQuerySet(models.QuerySet):
	    def recent(self):
	        week_ago = timezone.now() - timedelta(days=7)
	        return self.filter(created_at__gte=week_ago)

	Usage:
		Entry.objects.published().recent()


âœ” Example B â€” search helper
	class EntryQuerySet(models.QuerySet):
	    def search(self, keyword):
	        return self.filter(title__icontains=keyword)

	Usage:
		Entry.objects.search("django").popular()


âœ” Example C â€” filter by multiple statuses
	class EntryQuerySet(models.QuerySet):
	    def status(self, published=None, min_likes=None):
	        qs = self
	        if published is not None:
	            qs = qs.filter(published=published)
	        if min_likes is not None:
	            qs = qs.filter(likes__gte=min_likes)
	        return qs

	Usage:
		Entry.objects.status(published=True, min_likes=50)




-------------------------------------------------------------
Using Custom QuerySet as Default Manager
-------------------------------------------------------------
> Manager.from_queryset auto-exposes all QuerySet methods.

âœ” Example â€” clean and modern
	class EntryQuerySet(models.QuerySet):
	    def published(self):
	        return self.filter(published=True)

	    def popular(self):
	        return self.filter(likes__gte=100)

	    def search(self, keyword):
	        return self.filter(title__icontains=keyword)


	Manager made automatically:
		EntryManager = models.Manager.from_queryset(EntryQuerySet)


	Attach to model:
		class Entry(models.Model):
		    ...
		    objects = EntryManager()


âœ” Chainable usage (super clean)
	Entry.objects.published().search("python").popular()




-------------------------------------------------------------
Advanced Business Logic Examples
-------------------------------------------------------------

âœ” Example A â€” "active" records pattern
	class EntryQuerySet(models.QuerySet):
	    def active(self):
	        return self.filter(published=True, likes__gt=0)

	Usage:
		Entry.objects.active().order_by("-likes")


âœ” Example B â€” annotate & filter pattern
	from django.db.models import Count

	class EntryQuerySet(models.QuerySet):
	    def with_comment_count(self):
	        return self.annotate(comment_count=Count("comments"))

	Usage:
		Entry.objects.with_comment_count().filter(comment_count__gt=5)


âœ” Example C â€” combine two methods for readable queries
	Entry.objects.published().popular().recent().search("django")











------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------














13. Performance Optimization



-------------------------------------------------------------
.only()	Load only certain fields.
-------------------------------------------------------------
> Loads only a subset of fields; all other fields become deferred.


âœ” Example 1 â€” Load only names
	authors = Author.objects.only("name")
	authors[0].name â†’ loaded immediately
	authors[0].bio â†’ triggers extra DB query because it's deferred.

âœ” Example 2 â€” Only title & created date of Entries
	entries = Entry.objects.only("title", "created_at")

âœ” Example 3 â€” Combine with select_related
	entries = Entry.objects.select_related("blog").only(
	    "title", "blog__name"
	)



-------------------------------------------------------------
.defer()	Load all except some fields.
-------------------------------------------------------------
> Opposite of .only().

âœ” Example 1 â€” Defer large text content
	entries = Entry.objects.defer("content")

âœ” Example 2 â€” Defer multiple fields
	entries = Entry.objects.defer("content", "updated_at")

âœ” Example 3 â€” Defer related object fields
	entries = Entry.objects.select_related("blog").defer("blog__description")


-------------------------------------------------------------
Database indexes	Speed up filters.
-------------------------------------------------------------
> Indexes speed up filters and ordering.

âœ” Example 1 â€” Add index to Blog name
	class Blog(models.Model):
	    name = models.CharField(max_length=200, db_index=True)

âœ” Example 2 â€” Add composite index
	Searchable by (author, created_at):
	class Entry(models.Model):
	    class Meta:
	        indexes = [
	            models.Index(fields=["author", "created_at"])
	        ]

âœ” Example 3 â€” Unique index (alternative to unique_together)
	class Author(models.Model):
	    email = models.EmailField(unique=True)



-------------------------------------------------------------
Avoiding N+1 queries	#1 ORM performance issue.
-------------------------------------------------------------

use:
	- select_related
	- prefetch_related
	- .count
	- .exist
	- .iterator
	- .values
	- .value_list
	- caching (Optional but powerful)
		from django.core.cache import cache
		entries = cache.get_or_set("entries_list", Entry.objects.all(), 300)


avoid:
	- order_by #unless needed


updaing:
	Bad:
		entry = Entry.objects.get(id=1)
		entry.title = "New"
		entry.save()

	Good:
		Entry.objects.filter(id=1).update(title="New")




